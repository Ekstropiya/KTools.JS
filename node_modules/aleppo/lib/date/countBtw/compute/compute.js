'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _info = require('../../info');

// return array date. [ d, m ,y]
var dateArray = function dateArray(ts) {
  return [ts.getUTCDate(), ts.getUTCMonth(), ts.getUTCFullYear()];
};

/**
 * choose the bigger ts value, avoiding error in calculations
 * all functions use this guy.
 *
 * @param {timestamp1}
 * @param {timestamp1}
 * @returns {array} - arrays containing two arrays. [frm[day,month,year], until[day,month,year]]
 **/
var sortAndSolveTs = function sortAndSolveTs(timestamp1, timestamp2) {
  var ts1 = new Date(timestamp1);
  var ts2 = new Date(timestamp2);
  if (ts1 > ts2) {
    return [// from date array
    dateArray(ts2), dateArray(ts1)];
  }
  // else default.
  return [dateArray(ts1), dateArray(ts2)];
};

/**
 * fraction-functions.
 * since it's being repeated in each function,
 * i isolated them for better performance.
 **/

// 1- same month and same year, then just count days.
// we need this function in all counting-functions
var isSameMonthAndYear = function isSameMonthAndYear(yfrm, ytl, mfrm, mtl) {
  return yfrm === ytl && mfrm === mtl;
};

// if isSameMonthAndYear then count.
var countInDaysRange = function countInDaysRange(dfrm, dtl) {
  var counter = 0;
  for (var i = dfrm; !(i === dtl); i += 1) {
    counter += 1;
  }
  return counter;
};

var looping = function looping(yfrm, ytl, mfrm, mtl) {
  var type = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'o';

  var monthBegin = mfrm;
  var yearBegin = yfrm;
  var counter = 0;
  while (!(yearBegin === ytl && monthBegin === mtl)) {
    if (type === 'd') {
      counter += (0, _info.daysCountInMonth)(monthBegin, yearBegin, true);
    } else {
      // year or month.
      counter += 1;
    }
    monthBegin += 1;
    if (monthBegin === 12) {
      monthBegin = 0;
      yearBegin += 1;
    }
  }
  return counter;
};

/**
 * end of fraction-functions ***************************************************
 **/

/**
 * operational function, works for daysBtw.
 * counting the days difference between from and until.
 * last day in until not included.
 * @param {array}
 * @param {array}
 * @returns {number} - days between.
 **/
var computeDaysBtw = function computeDaysBtw(frm, tl, i) {
  var _ref = [frm[1], frm[2]],
      mfrm = _ref[0],
      yfrm = _ref[1];

  var dfrm = frm[0];
  var _ref2 = [tl[0], tl[1], tl[2]],
      dtl = _ref2[0],
      mtl = _ref2[1],
      ytl = _ref2[2];
  // same month and same year, then just count days.

  if (isSameMonthAndYear(yfrm, ytl, mfrm, mtl)) {
    return i ? countInDaysRange(dfrm, dtl) + 1 : countInDaysRange(dfrm, dtl);
  }
  var counter = 0;
  if (dfrm !== 1) {
    // not from beginning of the month
    // compute the day difference and add one to include from day.
    // add new month
    mfrm += 1;
    if (mfrm === 12) {
      mfrm = 0;
      yfrm += 1;
    }
    counter += (0, _info.daysCountInMonth)(mfrm, yfrm) - dfrm + 1;
  }
  if (dtl !== 1) {
    // not from beginning of the month
    // add the days to the counter, -1 not include the last day
    counter += tl[0] - 1;
  }
  // if ((dtl === 1 && dfrm !== 1) && (dtl !== 1 && dfrm === 1)) {
  //   // if both not from 1 then sub 1 to exclude the last day
  //   counter -= 1;
  // }
  counter += looping(yfrm, ytl, mfrm, mtl, 'd');
  // if include the last day then add one.
  if (i) counter += 1;
  return counter;
};

/**
 * main function.
 *
 * @param {array}
 * @param {array}
 * @param {boolean} - i to include the last day in the end.
 * @returns {object} - {days: }
 **/
var daysBtw = function daysBtw(timestamp1, timestamp2, i) {
  var _sortAndSolveTs = sortAndSolveTs(timestamp1, timestamp2),
      _sortAndSolveTs2 = _slicedToArray(_sortAndSolveTs, 2),
      frm = _sortAndSolveTs2[0],
      tl = _sortAndSolveTs2[1];

  var daysCounter = 0;
  daysCounter = computeDaysBtw(frm, tl, i);
  return {
    days: daysCounter
  };
};

/**
 * operational and main
 * computes how many weeks between two dates
 * depending on days count divided by seven
 *
 * @param {array}
 * @param {array}
 * @param {boolean} - i to include the last day in the end.
 * @param  {number} - number of days, since this functiona can be called by all function
 * in all function we already computed days.
 * @returns {object} - {weeks , daysLeft as days}
 **/
var weeksBtw = function weeksBtw(timestamp1, timestamp2, i) {
  var days = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var daysCountBtw = 0;
  if (!days) {
    daysCountBtw = daysBtw(timestamp1, timestamp2, i).days;
  } else {
    daysCountBtw = days;
  }
  var remainder = daysCountBtw % 7;
  var weeks = 0;
  var daysLeft = 0;
  if (remainder === 0) {
    weeks = daysCountBtw / 7;
  } else {
    daysLeft = remainder;
    weeks = (daysCountBtw - remainder) / 7;
  }
  return {
    weeks: weeks,
    days: daysLeft
  };
};

/**
 * operational function, works for monthsBtw.
 * counting the months and days difference between from and until.
 * last day in until not included.
 * same as computeMonthsBtw with small dif.
 *
 * @param {array}
 * @param {array}
 * @returns {objects} - {months , days}
 **/
var computeMonthsBtw = function computeMonthsBtw(frm, tl, i) {
  var _ref3 = [frm[1], frm[2]],
      mfrm = _ref3[0],
      yfrm = _ref3[1];

  var dfrm = frm[0];
  var _ref4 = [tl[0], tl[1], tl[2]],
      dtl = _ref4[0],
      mtl = _ref4[1],
      ytl = _ref4[2];

  var daysCounter = 0;
  var monthsCounter = 0;
  // same month and same year, then just count days.
  if (isSameMonthAndYear(yfrm, ytl, mfrm, mtl)) {
    return {
      months: 0,
      days: i ? countInDaysRange(dfrm, dtl) + 1 : countInDaysRange(dfrm, dtl)
    };
  }
  if (dfrm !== 1) {
    // not from beginning of the month
    // compute the day difference and add one to include from day.
    // add new month
    mfrm += 1;
    if (mfrm === 12) {
      mfrm = 0;
      yfrm += 1;
    }
    daysCounter += (0, _info.daysCountInMonth)(mfrm, yfrm) - dfrm + 1;
  }
  if (dtl !== 1) {
    // not from beginning of the month
    // add the days to the counter, -1 not include the last day
    daysCounter += tl[0] - 1;
  }
  // if ((dtl === 1 && dfrm !== 1) && (dtl !== 1 && dfrm === 1)) {
  //   // if both not from 1 then sub 1 to exclude the last day
  //   daysCounter -= 1;
  // }
  monthsCounter += looping(yfrm, ytl, mfrm, mtl);
  if (i) daysCounter += 1;
  return {
    months: monthsCounter,
    days: daysCounter
  };
};

/**
 * main function.
 *
 * @param {array}
 * @param {array}
 * @param {boolean} - i to include the last day in the end.
 * @returns {object} - {days: }
 **/
var monthsBtw = function monthsBtw(timestamp1, timestamp2, i) {
  var _sortAndSolveTs3 = sortAndSolveTs(timestamp1, timestamp2),
      _sortAndSolveTs4 = _slicedToArray(_sortAndSolveTs3, 2),
      frm = _sortAndSolveTs4[0],
      tl = _sortAndSolveTs4[1];

  return computeMonthsBtw(frm, tl, i);
};

/**
 * operational function, works for yearsBtw.
 * counting the months and days difference between from and until.
 * last day in until not included.
 * same as computeMonthsBtw with small dif.
 *
 * @param {array}
 * @param {array}
 * @returns {objects} - {years, months , days}
 **/
var computeYearsBtw = function computeYearsBtw(frm, tl, i) {
  var _ref5 = [frm[1], frm[2]],
      mfrm = _ref5[0],
      yfrm = _ref5[1];

  var dfrm = frm[0];
  var _ref6 = [tl[0], tl[1], tl[2]],
      dtl = _ref6[0],
      mtl = _ref6[1],
      ytl = _ref6[2];

  var daysCounter = 0;
  var monthsCounter = 0;
  var yearsCounter = 0;
  // same month and same year, then just count days.
  if (isSameMonthAndYear(yfrm, ytl, mfrm, mtl)) {
    return {
      years: 0,
      months: 0,
      days: countInDaysRange(dfrm, dtl) + 1
    };
  }
  if (dfrm !== 1) {
    // not from beginning of the month
    // compute the day difference and add one to include from day.
    // add new month
    mfrm += 1;
    if (mfrm === 12) {
      mfrm = 0;
      yfrm += 1;
    }
    daysCounter += (0, _info.daysCountInMonth)(mfrm, yfrm) - dfrm + 1;
  }
  if (dtl !== 1) {
    // not from beginning of the month
    // add the days to the counter, -1 not include the last day
    daysCounter += tl[0] - 1;
  }
  // if ((dtl === 1 && dfrm !== 1) && (dtl !== 1 && dfrm === 1)) {
  //   // if both not from 1 then sub 1 to exclude the last day
  //   daysCounter -= 1;
  // }
  monthsCounter += looping(yfrm, ytl, mfrm, mtl);
  var remainder = monthsCounter % 12;
  if (remainder === 0) {
    yearsCounter = monthsCounter / 12;
    monthsCounter = 0;
  } else {
    yearsCounter = (monthsCounter - remainder) / 12;
    monthsCounter = remainder;
  }
  if (i) daysCounter += 1;
  return {
    years: yearsCounter,
    months: monthsCounter,
    days: daysCounter
  };
};

var yearsBtw = function yearsBtw(timestamp1, timestamp2, i) {
  var _sortAndSolveTs5 = sortAndSolveTs(timestamp1, timestamp2),
      _sortAndSolveTs6 = _slicedToArray(_sortAndSolveTs5, 2),
      frm = _sortAndSolveTs6[0],
      tl = _sortAndSolveTs6[1];

  return computeYearsBtw(frm, tl, i);
};

var all = function all(timestamp1, timestamp2, i) {
  var _sortAndSolveTs7 = sortAndSolveTs(timestamp1, timestamp2),
      _sortAndSolveTs8 = _slicedToArray(_sortAndSolveTs7, 2),
      frm = _sortAndSolveTs8[0],
      tl = _sortAndSolveTs8[1];

  var fulldays = computeDaysBtw(frm, tl, i);
  var fullweeks = weeksBtw(null, null, i, fulldays);
  var fullmonths = computeMonthsBtw(frm, tl, i);
  var fullYears = computeYearsBtw(frm, tl, i);
  return {
    inDays: fulldays,
    inWeeks: fullweeks,
    inMonths: fullmonths,
    inYears: fullYears
  };
};

module.exports = {
  daysBtw: daysBtw,
  weeksBtw: weeksBtw,
  monthsBtw: monthsBtw,
  yearsBtw: yearsBtw,
  all: all,
  // export for laterAgo function
  computeDaysBtw: computeDaysBtw
};